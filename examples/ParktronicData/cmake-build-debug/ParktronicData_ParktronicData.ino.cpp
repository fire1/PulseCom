// automatically generated by arduino-cmake
#line 1 "C:/Users/Admin/Documents/Arduino/ParktronicData/ParktronicData.ino"
#include <Arduino.h>
#include <EnableInterrupt.h>

#line 6 "C:/Users/Admin/Documents/Arduino/ParktronicData/cmake-build-debug/ParktronicData_ParktronicData.ino.cpp"
#include "Arduino.h"

//=== START Forward: C:/Users/Admin/Documents/Arduino/ParktronicData/ParktronicData.ino
     static void isr() ;
     static void isr() ;
     void begin();
     void begin();
     void listener();
     void listener();
 void echoComISR() ;
 void echoComISR() ;
 void setup() ;
 void setup() ;
 void loop() ;
 void loop() ;
//=== END Forward: C:/Users/Admin/Documents/Arduino/ParktronicData/ParktronicData.ino
#line 2 "C:/Users/Admin/Documents/Arduino/ParktronicData/ParktronicData.ino"


class PulseCom {

    static boolean isStartedPulse = false;
    static byte state;
    static uint8_t pin;
    uint16_t b0, biteValue, timeout;
    static volatile uint16_t pulseTime;
    static volatile uint32_t startTime;


    PulseCom(uint8_t inputPin, uint16_t bit0Time, uint16_t bit1Time, byte stateCapture = HIGH,
             uint16_t pulseTimeout = 2000) {
        pin = inputPin;
        b0 = bit0Time;
        biteValue = bit1Time;
        state = stateCapture;
        timeout = pulseTimeout;

    }

public:
    static void isr() {
        if (digitalRead(pin) == state && !isStartedPulse) { // Listen the state
            startTime = millis();
            isStartedPulse = true;
            pulseTime = 0;
        } else {
            pulseTime = millis() - startTime;
            isStartedPulse = false;
        }
    }


    void begin(){
        enableInterrupt(pin, this->isr(), CHANGE);
    }


    void listener(){

    }


};

void echoComISR() {
    static unsigned long startTime;

    if (digitalRead(PRK_INPUT) == PRK_PIN_STATE) // Listen the state
        startTime = millis();
    else {  // Change state
        lpgPulseTime = millis() - startTime;

        if (lpgPulseTime >= PRK_TIMEOUT) {
            lpgDataBuffer = '\0';
            lpgDataOffset = 0;
            lpgPulseTime = 0;
            return;
        }

        if (lpgDataOffset >= PRK_BITS) {
            lpgDataBuffer = '\0';
            lpgDataOffset = 0;
        }

        if (lpgPulseTime > (PRK_BYTE_B1 - PRK_BYTE_TS) && lpgPulseTime <= (PRK_BYTE_B1 + PRK_BYTE_TS)) {
            lpgDataBuffer |= 1 << lpgDataOffset;
            lpgDataOffset++;
        } else if (lpgPulseTime > (PRK_BYTE_B0 - PRK_BYTE_TS) && lpgPulseTime <= (PRK_BYTE_B0 + PRK_BYTE_TS)) {
            lpgDataBuffer |= 0 << lpgDataOffset;
            lpgDataOffset++;
        }

#ifdef LPG_TIME_SENS
        dumper[lpgDataOffset] = lpgPulseTime;
        lpgDataOffset++;
        if (lpgDataOffset >= 14) {
            lpgDataOffset = 0;
        }

#endif
    }
}


void setup() {


}

void loop() {


}

